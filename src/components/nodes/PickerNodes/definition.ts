import { NodeDefinition } from '../definitions/types.js';
import {
  FlowDataType,
  PickCharacterNodeDataSchema,
  PickLorebookNodeDataSchema,
  PickMathOperationNodeDataSchema,
  PickPromptEngineeringModeNodeDataSchema,
  PickPromptNodeDataSchema,
  PickRandomModeNodeDataSchema,
  PickRegexModeNodeDataSchema,
  PickRegexScriptNodeDataSchema,
  PickStringToolsOperationNodeDataSchema,
  PickTypeConverterTargetNodeDataSchema,
} from '../../../flow-types.js';
import {
  PickCharacterNode,
  PickLorebookNode,
  PickMathOperationNode,
  PickPromptEngineeringModeNode,
  PickPromptNode,
  PickRandomModeNode,
  PickRegexModeNode,
  PickRegexScriptNode,
  PickStringToolsOperationNode,
  PickTypeConverterTargetNode,
} from './PickerNodes.js';
import { registrator } from '../registrator.js';
import { NodeExecutor } from '../../../NodeExecutor.js';
import { PromptEngineeringMode } from '../../../config.js';

const pickerExecutors: Record<string, NodeExecutor> = {
  pickCharacterNode: async (node) => ({ avatar: PickCharacterNodeDataSchema.parse(node.data).characterAvatar }),
  pickLorebookNode: async (node) => ({ name: PickLorebookNodeDataSchema.parse(node.data).worldName }),
  pickPromptNode: async (node) => ({ name: PickPromptNodeDataSchema.parse(node.data).promptName }),
  pickRegexScriptNode: async (node) => ({ id: PickRegexScriptNodeDataSchema.parse(node.data).scriptId }),
  pickMathOperationNode: async (node) => ({ operation: PickMathOperationNodeDataSchema.parse(node.data).operation }),
  pickStringToolsOperationNode: async (node) => ({
    operation: PickStringToolsOperationNodeDataSchema.parse(node.data).operation,
  }),
  pickPromptEngineeringModeNode: async (node) => ({
    mode: PickPromptEngineeringModeNodeDataSchema.parse(node.data).mode,
  }),
  pickRandomModeNode: async (node) => ({ mode: PickRandomModeNodeDataSchema.parse(node.data).mode }),
  pickRegexModeNode: async (node) => ({ mode: PickRegexModeNodeDataSchema.parse(node.data).mode }),
  pickTypeConverterTargetNode: async (node) => ({
    type: PickTypeConverterTargetNodeDataSchema.parse(node.data).targetType,
  }),
};

const definitions: NodeDefinition[] = [
  {
    type: 'pickCharacterNode',
    label: 'Pick Character',
    category: 'Picker',
    component: PickCharacterNode,
    dataSchema: PickCharacterNodeDataSchema,
    currentVersion: 1,
    initialData: { characterAvatar: '', _version: 1 },
    handles: { inputs: [], outputs: [{ id: 'avatar', type: FlowDataType.STRING }] },
    execute: pickerExecutors.pickCharacterNode,
  },
  {
    type: 'pickLorebookNode',
    label: 'Pick Lorebook',
    category: 'Picker',
    component: PickLorebookNode,
    dataSchema: PickLorebookNodeDataSchema,
    currentVersion: 1,
    initialData: { worldName: '', _version: 1 },
    handles: { inputs: [], outputs: [{ id: 'name', type: FlowDataType.STRING }] },
    execute: pickerExecutors.pickLorebookNode,
  },
  {
    type: 'pickPromptNode',
    label: 'Pick Prompt',
    category: 'Picker',
    component: PickPromptNode,
    dataSchema: PickPromptNodeDataSchema,
    currentVersion: 1,
    initialData: { promptName: '', _version: 1 },
    handles: { inputs: [], outputs: [{ id: 'name', type: FlowDataType.STRING }] },
    execute: pickerExecutors.pickPromptNode,
  },
  {
    type: 'pickRegexScriptNode',
    label: 'Pick Regex Script',
    category: 'Picker',
    component: PickRegexScriptNode,
    dataSchema: PickRegexScriptNodeDataSchema,
    currentVersion: 1,
    initialData: { scriptId: '', _version: 1 },
    handles: { inputs: [], outputs: [{ id: 'id', type: FlowDataType.STRING }] },
    execute: pickerExecutors.pickRegexScriptNode,
  },
  {
    type: 'pickMathOperationNode',
    label: 'Pick Math Operation',
    category: 'Picker',
    component: PickMathOperationNode,
    dataSchema: PickMathOperationNodeDataSchema,
    currentVersion: 1,
    initialData: { operation: 'add', _version: 1 },
    handles: { inputs: [], outputs: [{ id: 'operation', type: FlowDataType.STRING }] },
    execute: pickerExecutors.pickMathOperationNode,
  },
  {
    type: 'pickStringToolsOperationNode',
    label: 'Pick String Operation',
    category: 'Picker',
    component: PickStringToolsOperationNode,
    dataSchema: PickStringToolsOperationNodeDataSchema,
    currentVersion: 1,
    initialData: { operation: 'merge', _version: 1 },
    handles: { inputs: [], outputs: [{ id: 'operation', type: FlowDataType.STRING }] },
    execute: pickerExecutors.pickStringToolsOperationNode,
  },
  {
    type: 'pickPromptEngineeringModeNode',
    label: 'Pick Prompt Mode',
    category: 'Picker',
    component: PickPromptEngineeringModeNode,
    dataSchema: PickPromptEngineeringModeNodeDataSchema,
    currentVersion: 1,
    initialData: { mode: PromptEngineeringMode.NATIVE, _version: 1 },
    handles: { inputs: [], outputs: [{ id: 'mode', type: FlowDataType.STRING }] },
    execute: pickerExecutors.pickPromptEngineeringModeNode,
  },
  {
    type: 'pickRandomModeNode',
    label: 'Pick Random Mode',
    category: 'Picker',
    component: PickRandomModeNode,
    dataSchema: PickRandomModeNodeDataSchema,
    currentVersion: 1,
    initialData: { mode: 'number', _version: 1 },
    handles: { inputs: [], outputs: [{ id: 'mode', type: FlowDataType.STRING }] },
    execute: pickerExecutors.pickRandomModeNode,
  },
  {
    type: 'pickRegexModeNode',
    label: 'Pick Regex Mode',
    category: 'Picker',
    component: PickRegexModeNode,
    dataSchema: PickRegexModeNodeDataSchema,
    currentVersion: 1,
    initialData: { mode: 'sillytavern', _version: 1 },
    handles: { inputs: [], outputs: [{ id: 'mode', type: FlowDataType.STRING }] },
    execute: pickerExecutors.pickRegexModeNode,
  },
  {
    type: 'pickTypeConverterTargetNode',
    label: 'Pick Conversion Type',
    category: 'Picker',
    component: PickTypeConverterTargetNode,
    dataSchema: PickTypeConverterTargetNodeDataSchema,
    currentVersion: 1,
    initialData: { targetType: 'string', _version: 1 },
    handles: { inputs: [], outputs: [{ id: 'type', type: FlowDataType.STRING }] },
    execute: pickerExecutors.pickTypeConverterTargetNode,
  },
];

definitions.forEach((def) => registrator.register(def));
